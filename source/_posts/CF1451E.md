---
title: Codeforces Round 685 (Div. 2) E Bitwise Queries
date: 2020-11-22 12:09:45
category: 競技プログラミング
mathjax: true
---

## 問題概要

リンク: https://codeforces.com/contest/1451/problem/E1
インタラクション問題
整数配列の異なる二数の AND, OR, XOR のいずれかを$n+3(hard: n+2)$回聞くことで配列自体を特定する。
制約: $2^2 \leq n \leq 2^{16}, n = 2^k$, $0 \leq a_i \leq n$

## key

$a_2 \ \oplus \ a_3 = (a_1 \ \oplus \ a_2) \ \oplus \ (a_2 \ \oplus \ a_3)$
$a_i + a_j = (a_i \ \wedge \ a_j) + (a_i \ \vee \ a_j) = (a_i \ \oplus \ a_j) + 2(a_i \ \wedge \ a_j)$
$(a_i \ \wedge \ a_j) = (a_i \ \oplus \ a_j) + (a_i \ \vee \ a_j)$

## 解法 1(Easy)

想定解.
$a_i + a_j = (a_i \ \oplus \ a_j) + 2(a_i \ \wedge \ a_j)$より
$a_1 + a_2 = x$, $a_2 + a_3 = y$, $a_1 + a_3 = z$が 6 回の query でわかるので$a_1 = \frac{(x - y + z)}{2}, a_2, a_3$が特定できる。
ここで$a_2 \ \oplus \ a_3 = (a_1 \ \oplus \ a_2) \ \oplus \ (a_2 \ \oplus \ a_3)$よりこれを 5 回に削減可能. 残りの要素は前の要素との XOR を調べることで判定できる。
最後の削減ができず...

## 解法 2(Easy)

解答: (https://codeforces.com/contest/1451/submission/99209729)
コンテスト後, これで解いた. hard の想定解の一部に似ている。
以降$a_i$の qbit 目を$b_i$とする. $b_1$は 1 か 0 のいずれかである。 ここで$b_1$がわかっていると仮定すると b_2 は$b_1$と$b_2$の XOR より判定できる。
以降 nbit 目まで XOR をとっていくことで配列 b が$b_1$が 1, 0 の２つの場合で定まる。よってこれまでに必要な query は n-1 回. 残り 3 回の query で$b_1$が特定できれば解ける。

1. $b_1 \oplus b_2 = 0$の場合
   {$b_1, b_2$} = {0, 0} or {1, 1}なので$a_1, a_2$について AND を取れば ok
2. $b_1 \oplus b_2 = 1$かつ$b_2 \oplus b_3 = 1$の場合
   $a_1, a_3$について AND を取れば ok
3. $b_1 \oplus b_2 = 1$かつ$b_2 \oplus b_3 = 0$の場合
   $a_2, a_3$について AND を取れば ok

以上より事前に{$a_1, a_2$}, {$a_2, a_3$}, {$a_1, a_3$}それぞれの AND 取得しておけば n+2 回で解ける。
時間計算量: $O(NlogN)$

## 解法 1(Hard)

上記解法 2(Easy)の XOR は順番に取る必要はなく, 全て$a_1$ととっても ok

1. $a_i$に被りがある場合, $a_1$との XOR が同一となった数は同一なのであとは XOR をたどることで n 回で ok
2. 被りがない場合, a には 0 から n-1 のすべての値が含まれる。 ここで$a_1 \oplus a_i = n-1$になるような i は必ず存在し, このとき, $a_1 \oplus a_i = a_1 + a_i = (a_1 \ \oplus \ a_i) + 2(a_1 \ \wedge \ a_i)$よって AND が分かり, 一つ減らすことができる。
